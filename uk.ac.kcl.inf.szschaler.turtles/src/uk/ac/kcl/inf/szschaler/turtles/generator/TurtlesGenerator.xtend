/*
 * generated by Xtext 2.18.0.M3
 */
package uk.ac.kcl.inf.szschaler.turtles.generator

import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import uk.ac.kcl.inf.szschaler.turtles.turtles.Expression
import uk.ac.kcl.inf.szschaler.turtles.turtles.IntLiteral
import uk.ac.kcl.inf.szschaler.turtles.turtles.LoopStatement
import uk.ac.kcl.inf.szschaler.turtles.turtles.MoveStatement
import uk.ac.kcl.inf.szschaler.turtles.turtles.PenMoveStatement
import uk.ac.kcl.inf.szschaler.turtles.turtles.PenState
import uk.ac.kcl.inf.szschaler.turtles.turtles.RealLiteral
import uk.ac.kcl.inf.szschaler.turtles.turtles.Statement
import uk.ac.kcl.inf.szschaler.turtles.turtles.TurnCommand
import uk.ac.kcl.inf.szschaler.turtles.turtles.TurnStatement
import uk.ac.kcl.inf.szschaler.turtles.turtles.TurtleProgram
import uk.ac.kcl.inf.szschaler.turtles.turtles.TurtlesPackage
import uk.ac.kcl.inf.szschaler.turtles.turtles.VariableDeclaration

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class TurtlesGenerator extends AbstractGenerator {

	private static class ConstantFolder extends ETLRunner {

		val Resource inModel

		new(Resource inModel) {
			this.inModel = inModel
		}

		override protected getSource() {
			"constant_fold.etl"
		}

		override protected getModels() throws Exception {
			#[
				inModel.createInMemoryEmfModel("Source", TurtlesPackage.eNS_URI),
				inModel.resourceSet.createResource(URI.createFileURI("synthetic.turtles")).
					createInMemoryEmfModel("Target", TurtlesPackage.eNS_URI)
			]
		}

	}

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.contents.head as TurtleProgram
		fsa.generateFile(resource.deriveStatsTargetFileNameFor, model.doGenerateStats)

		val className = resource.deriveClassNameFor

		val interimModel = new ConstantFolder(resource).execute as TurtleProgram 
		
		fsa.generateFile(className + '.java', interimModel.doGenerateClass(className))
	}

	def deriveStatsTargetFileNameFor(Resource resource) {
		resource.URI.appendFileExtension('txt').lastSegment
	}

	def deriveClassNameFor(Resource resource) {
		val origName = resource.URI.lastSegment

		origName.substring(0, origName.indexOf('.')).toFirstUpper + 'Turtle'
	}

	def String doGenerateStats(TurtleProgram program) '''
		Program contains:
		
		- «program.eAllContents.filter(TurnStatement).size» turn commands
		- «program.eAllContents.filter(MoveStatement).size» move commands
		- «program.statements.filter(LoopStatement).size» top-level loops
		- «program.eAllContents.filter(VariableDeclaration).size» variable declarations
	'''

	def String doGenerateClass(TurtleProgram program, String className) '''
		import uk.ac.kcl.inf.szschaler.turtles.library.*;
		
		public class «className» {
		
			public static void main (String[] args) {
				TurtlesFrame tf = new TurtlesFrame();
				
				Turtle t = new Turtle(tf) {
					@Override
					public void run() {
						«program.statements.map[generateJavaStatement(new Environment)].join('\n')»
					}
				};
				
				t.run();
			}
		}
	'''

	private static class Environment {
		var int counter = 0

		def getFreshVarName() '''i«counter++»'''

		def exit() { counter-- }
	}

	dispatch def String generateJavaStatement(Statement stmt, Environment env) ''''''

	dispatch def String generateJavaStatement(MoveStatement stmt,
		Environment env) '''move«stmt.command.getName.toFirstUpper»(«stmt.steps.generateJavaExpression»);'''

	dispatch def String generateJavaStatement(TurnStatement stmt,
		Environment env) '''rotate(«if (stmt.command === TurnCommand.LEFT) {'''-'''}»«stmt.degrees.generateJavaExpression»);'''

	dispatch def String generateJavaStatement(PenMoveStatement stmt,
		Environment env) '''penUp(«stmt.state === PenState.UP»);'''

	dispatch def String generateJavaStatement(LoopStatement stmt, Environment env) {
		val freshVarName = env.getFreshVarName

		val result = '''
			for (int «freshVarName» = 0; «freshVarName» < «stmt.count.generateJavaExpression»; «freshVarName»++) {
				«stmt.statements.map[generateJavaStatement(env)].join('\n')»
			}
		'''

		env.exit

		result
	}

	dispatch def String generateJavaExpression(Expression exp) {}

	dispatch def String generateJavaExpression(IntLiteral exp) '''«exp.^val»'''

	dispatch def String generateJavaExpression(RealLiteral exp) '''«exp.^val»f'''
}
